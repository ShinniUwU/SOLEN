# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Prepare release tarball
        run: |
          set -euxo pipefail
          mkdir -p site/releases
          # Require core files and libs
          test -f serverutils
          test -f Scripts/install/install.sh
          test -f Scripts/motd/solen-motd.sh
          test -f Scripts/lib/solen.sh
          test -f Scripts/lib/edit.sh
          test -f Scripts/lib/pm.sh
          test -f Scripts/lib/policy.sh
          # Update scripts present
          test -f Scripts/update/check.sh
          test -f Scripts/update/apply.sh
          test -f Scripts/update/status.sh
          # Determine version from serverutils (robust)
          base_ver=$(awk -F '"' '/^VERSION=/ {print $2; exit}' serverutils)
          if [ -z "${base_ver:-}" ]; then echo "VERSION not found in serverutils" >&2; exit 1; fi
          build_date=$(date -u +"%F")
          short_sha=$(git rev-parse --short HEAD)
          full_ver="${base_ver}+${build_date}.g${short_sha}"
          echo "Computed full version: $full_ver"
          # Stage build with VERSION baked in
          rm -rf build && mkdir -p build
          cp -a serverutils Scripts asset systemd config asciiart.ascii build/
          sed -i "s/^VERSION=\".*\"/VERSION=\"${full_ver}\"/" build/serverutils
          # Build versioned tarball with runner + scripts and assets
          ver_tar="site/releases/solen-${full_ver}.tar.gz"
          tar -czf "$ver_tar" -C build .
          # Verify tarball contains required libs (avoid SIGPIPE under pipefail)
          tmp_tar_list=$(mktemp)
          tar -tf "$ver_tar" > "$tmp_tar_list"
          grep -Fxq 'Scripts/lib/solen.sh' "$tmp_tar_list"
          grep -Fxq 'Scripts/lib/edit.sh' "$tmp_tar_list"
          grep -Fxq 'Scripts/lib/pm.sh' "$tmp_tar_list"
          grep -Fxq 'Scripts/lib/policy.sh' "$tmp_tar_list"
          rm -f "$tmp_tar_list"
          # Create channel pointers and legacy latest name
          cp -f "$ver_tar" site/releases/solen-stable.tar.gz
          cp -f "$ver_tar" site/releases/solen-rc.tar.gz
          cp -f "$ver_tar" site/releases/solen-nightly.tar.gz
          cp -f "$ver_tar" site/releases/solen-latest.tar.gz
          # Checksums for each published filename
          (cd site/releases && sha256sum "solen-${full_ver}.tar.gz" > "solen-${full_ver}.tar.gz.sha256")
          (cd site/releases && sha256sum solen-stable.tar.gz > solen-stable.tar.gz.sha256)
          (cd site/releases && sha256sum solen-rc.tar.gz > solen-rc.tar.gz.sha256)
          (cd site/releases && sha256sum solen-nightly.tar.gz > solen-nightly.tar.gz.sha256)
          (cd site/releases && sha256sum solen-latest.tar.gz > solen-latest.tar.gz.sha256)
      - name: Build channel manifests
        run: |
          set -euo pipefail
          base_ver=$(awk -F '"' '/^VERSION=/ {print $2; exit}' serverutils)
          test -n "$base_ver"
          build_date=$(date -u +"%F")
          short_sha=$(git rev-parse --short HEAD)
          ver="${base_ver}+${build_date}.g${short_sha}"
          sha_stable=$(awk '{print $1}' site/releases/solen-stable.tar.gz.sha256)
          sha_rc=$(awk '{print $1}' site/releases/solen-rc.tar.gz.sha256)
          sha_nightly=$(awk '{print $1}' site/releases/solen-nightly.tar.gz.sha256)
          base="https://solen.shinni.dev"
          url_stable="$base/releases/solen-stable.tar.gz"
          url_rc="$base/releases/solen-rc.tar.gz"
          url_nightly="$base/releases/solen-nightly.tar.gz"
          ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          # Optional signing: provide SOLEN_SIGNING_KEY_PEM secret (PEM-encoded RSA/EC)
          sign() {
            keyfile="$1"; data="$2"
            if base64 --help 2>&1 | grep -q '\-w'; then
              printf '%s' "$data" | openssl dgst -sha256 -sign "$keyfile" -binary | base64 -w0
            else
              printf '%s' "$data" | openssl dgst -sha256 -sign "$keyfile" -binary | base64 | tr -d '\n'
            fi
          }
          sig_algo="rsa-sha256"
          have_key=0
          if [ -n "${{ secrets.SOLEN_SIGNING_KEY_PEM }}" ]; then
            have_key=1
            printf '%s' "${{ secrets.SOLEN_SIGNING_KEY_PEM }}" > /tmp/solen_signing_key.pem
            # Compute public key fingerprint (sha256 of DER pubkey)
            pub_fp=$(openssl pkey -in /tmp/solen_signing_key.pem -pubout -outform DER 2>/dev/null | sha256sum | awk '{print $1}')
          fi
          build_manifest() {
            ch="$1"; url="$2"; sha="$3"
            sig=""; str="${ver}|${sha}|${url}|${ts}|${ch}"
            if [ $have_key -eq 1 ]; then sig=$(sign /tmp/solen_signing_key.pem "$str"); fi
            json='{ "channel":"'"${ch}"'", "version":"'"${ver}"'", "url":"'"${url}"'", "sha256":"'"${sha}"'", "breaking": false, "date":"'"${ts}"'", "notes_url":"'"${base}"'/CHANGELOG#v'"${ver}"'"'
            if [ -n "$sig" ]; then
              json+=', "sig_algo":"'"${sig_algo}"'", "sig_b64":"'"${sig}"'", "sig_fields":"version|sha256|url|date|channel", "sig_pubkey_fp":"sha256:'"${pub_fp}"'"'
            fi
            json+=' }'
            printf '%s\n' "$json" > "site/releases/manifest-${ch}.json"
          }
          build_manifest stable "$url_stable" "$sha_stable"
          build_manifest rc "$url_rc" "$sha_rc"
          build_manifest nightly "$url_nightly" "$sha_nightly"
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload only the static site contents
          path: 'site'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
